# vim: ft=sh
add_file() {
  add $@
}

add() {
  local file="$1"
  [ -e "$root/$file" ] && return 0

  local parent="${file%/*}"
  local canonical="$(readlink -f "$file")"
  local canonical_parent="$(readlink -f "$parent")"
  if [ "$file" != "$canonical" ]; then
    add "$canonical"
  fi

  if ! [ -e "$root/$parent" ]; then
    add "$parent"
  fi

  if [ "$parent" = "$canonical_parent" ]; then
    if [ -L "$file" ]; then
      add "$canonical"
      add_symlink "$canonical" "$file"
    elif [ -d "$file" ]; then
      mkdir -v --mode="$(stat -c "%a" "$file")" "$root/$file"
    else
      cp -vd --preserve=all "$file" "$root/$file"
    fi
  fi
}

add_symlink() {
  local target="$1"
  local source="$2"
  
  local parent="${source%/*}"
  local relative="$(relpath "$parent" "$target")"
  ln -sv "$relative" "$root/$source"
}

add_directory() {
  local dir="$1"
  find "$dir" | while read item; do
    add "$item"
    if [ -d "$item" ] && [ "$item" != "$dir" ]; then
      add_directory "$item"
    fi
  done
}

add_binary() {
  local binary="$1"
  if [ "${binary#/}" = "$binary" ]; then
    add_binary $(which "$binary")
  else
    [ -e "$root/$binary" ] && return 0
    add "$binary"
    add_binary_deps "$binary"
  fi
}

add_module() {
  local module="${1%.ko}"
  local firmware=()
  local path
  local field value

  modinfo -k "$kernel_version" -0 "$module" 2>/dev/null |\
  while IFS=':= ' read -r -d '' field value; do
    case "$field" in
      filename)
        path="$value"
        if [ -e "$root/$path" ]; then
          return 0
        fi
        ;;
      depends)
        IFS=',' read -r -a deps <<< "$value"
        local dep
        for dep in "${deps[@]}"; do
          add_module "$dep"
        done
        ;;
      firmware)
        add_firmware "$value"
        ;;
    esac
  done

  if [ -z "$path" ]; then
    echo "couldn't find kernel module $module"
    return 1
  fi

  add "$path"
}

add_firmware() {
  add "/lib/firmware/$1"
}

add_binary_deps() {
  local lddout=$(ldd "$binary" 2>/dev/null) || add_binary_bang "$binary"

  local regex='(/.+) \(0x[a-fA-F0-9]+\)'
  local line
  while read line; do
    if [[ "$line" =~ "$regex" ]]; then
      sodep="${BASH_REMATCH[1]}"
    elif [[ $line = *'not found' ]]; then
      echo "binary dependency \`%s' not found for \`%s'" "${line%% *}" "$1" >&2
      return 1
    fi

    [ -z "$sodep" ] && continue
    add_binary "$sodep"
  done <<< "$lddout"
}

add_binary_bang() {
  local binary="$1"
  local first="$(head -n1 "$binary")"
  if [[ "$first" =~ '^#!(\S+)' ]]; then
    add_binary "${BASH_REMATCH[1]}"
  fi
}

relpath() {
  local current="${2:+"$1"}"
  local target="${2:-"$1"}"
  [ "$target" != . ] || target=/
  target="/${target##/}"
  [ "$current" != . ] || current=/
  current="${current:="/"}"
  current="/${current##/}"
  local appendix="${target##/}"
  local relative=''
  while appendix="${target#"$current"/}"
    [ "$current" != '/' ] && [ "$appendix" = "$target" ]; do
    if [ "$current" = "$appendix" ]; then
      relative="${relative:-.}"
      echo "${relative#/}"
      return 0
    fi
    current="${current%/*}"
    relative="$relative${relative:+/}.."
  done
  relative="$relative${relative:+${appendix:+/}}${appendix#/}"
  echo "$relative"
}
